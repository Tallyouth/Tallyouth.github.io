<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker add 和 copy 的区别</title>
    <url>/2020/09/01/docker-add-%E5%92%8C-copy-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><strong><code>COPY</code> 和 <code>ADD</code> 都是 <code>Dockerfile</code> 中的指令，作用有些相似，都可以把文件从特定的位置复制到镜像中去</strong></p>
<h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>COPY 指令从 <code>&lt;src&gt;</code> 复制新的文件或目录，并将它们添加到 Docker 容器文件系统的 <code>&lt;dest&gt;</code> 的路径下。</p>
<p>使用方法：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code>  (包含空格的路径使用这种格式)</li>
</ul>
<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>使用方法：(和COPY基本一致)</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code>  (包含空格的路径使用这种格式)</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><p>ADD 指令可以让你使用 URL 作为 <code>&lt;src&gt;</code> 参数。当遇到 URL 时候，可以通过 URL 下载文件并且复制到 <code>&lt;dest&gt;</code>。</p>
</li>
<li><p>ADD 的另一个特性是自动解压文件的能力。如果 <code>&lt;src&gt;</code> 参数是一个可识别压缩格式（tar, gzip, bzip2, …）的本地文件<code>（注：无法实现同时下载并解压）</code>，就会被解压到指定容器文件系统的路径 <code>&lt;dest&gt;</code> 下。</p>
</li>
</ul>
<h3 id="从-URL-复制的-Dockerfile-最佳实践"><a href="#从-URL-复制的-Dockerfile-最佳实践" class="headerlink" title="从 URL 复制的 Dockerfile 最佳实践"></a>从 URL 复制的 Dockerfile 最佳实践</h3><p><code>ADD</code> 的最佳用途是将本地压缩包文件自动提取到镜像中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD code.tar.gz &#x2F;app&#x2F;</span><br></pre></td></tr></table></figure>

<p>由于镜像的体积很重要，所以强烈建议不要使用 ADD 从远程 URL 获取文件，我们应该使用 curl 或 wget 来代替。这样我们可以在解压后删除这些不再需要的文件，同时还也可以避免在镜像中生成额外的层。</p>
<p>我们应该避免以下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD http:&#x2F;&#x2F;example.com&#x2F;big.tar.xz &#x2F;usr&#x2F;src&#x2F;things&#x2F;</span><br><span class="line">RUN tar -xJf &#x2F;usr&#x2F;src&#x2F;things&#x2F;big.tar.xz -C &#x2F;usr&#x2F;src&#x2F;things \</span><br><span class="line">    &amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;things all \</span><br><span class="line">    &amp;&amp; rm -f &#x2F;usr&#x2F;src&#x2F;things&#x2F;big.tar.xz</span><br></pre></td></tr></table></figure>

<p>这个压缩包解压后，rm 命令处于独立的镜像层。</p>
<p>我们可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN mkdir -p &#x2F;usr&#x2F;src&#x2F;things \</span><br><span class="line">    &amp;&amp; curl -SL http:&#x2F;&#x2F;example.com&#x2F;big.tar.xz \</span><br><span class="line">    | tar -xJC &#x2F;usr&#x2F;src&#x2F;things \</span><br><span class="line">    &amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;things all</span><br></pre></td></tr></table></figure>

<p>curl 会下载这个压缩包并通过管道传给 tar 命令进行解压，这样也就不会在文件系统中留下这个压缩文件了。</p>
<p>对于不需要自动解压的文件或目录，应该始终使用 COPY。</p>
<p><strong><em>最后，认准一个原则：总是使用 COPY（除非我们明确需要 ADD）。</em></strong></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker cmd 和 entrypoint 的区别</title>
    <url>/2020/08/31/docker-cmd-%E5%92%8C-entrypoint-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><ol>
<li>如果docker run没有指定任何的执行命令或者dockerfile里面也没有entrypoint，那么，就会使用cmd指定的默认的执行命令执行。同时也从侧面说明了entrypoint的含义，它才是真正的容器启动以后要执行命令。所以这句话就给出了cmd命令的一个角色定位，它主要作用是默认的容器启动执行命令。（注意不是“全部”作用）</li>
</ol>
<hr>
<ol start="2">
<li>如果run命令后面有东西，那么后面的全部都会作为entrypoint的参数。如果run后面没有额外的东西，但是cmd有，那么cmd的全部内容会作为entrypoint的参数</li>
</ol>
<h3 id="cmd用法"><a href="#cmd用法" class="headerlink" title="cmd用法"></a>cmd用法</h3><ol>
<li><p>没有中括号的形式,那么命令command默认是在“/bin/sh -c”下执行的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">CMD echo &quot;hello cmd!&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>带有中括号的形式。这时，命令没有再任何shell终端环境下，如果我们要执行shell，必须把shell加入到中括号的参数中。这种用法就像一个c语言的exec函数，意思是我们要执行一个进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">CMD [&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, &quot;echo &#39;hello cmd!&#39;&quot;]</span><br></pre></td></tr></table></figure>
<p> <strong><em>需要注意，采用中括号形式，那么第一个参数必须是命令的全路径才行。而且，一个dockerfile至多只能有一个cmd，如果有多个，只有最后一个生效。<br>官网推荐采用这种方法.</em></strong></p>
</li>
</ol>
<h3 id="entrypoint用法"><a href="#entrypoint用法" class="headerlink" title="entrypoint用法"></a>entrypoint用法</h3><ol>
<li><p>没有中括号，在这种模式下，任何run和cmd的参数都无法被传入到entrypoint里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"> </span><br><span class="line">CMD [&quot;p in cmd&quot;]</span><br><span class="line">ENTRYPOINT echo</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cmd的参数没有被打印。</span><br><span class="line"></span><br><span class="line">&#x3D;&gt; docker run docker_id</span><br><span class="line">&#x3D;&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p>带中括号的，如果run命令后面有东西，那么后面的全部都会作为entrypoint的参数。如果run后面没有额外的东西，但是cmd有，那么cmd的全部内容会作为entrypoint的参数,官网推荐这种用法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"> </span><br><span class="line">CMD [&quot;p in cmd&quot;]</span><br><span class="line">ENTRYPOINT [&quot;echo&quot;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 不带参数</span><br><span class="line"></span><br><span class="line">&#x3D;&gt; docker run docker_id</span><br><span class="line">&#x3D;&gt; p in cmd</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 带参数</span><br><span class="line"></span><br><span class="line">&#x3D;&gt; docker run docker_id p in run</span><br><span class="line">&#x3D;&gt; p in run</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>灰灰减肥计划</title>
    <url>/2020/08/28/%E7%81%B0%E7%81%B0%E5%87%8F%E8%82%A5%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h3 id="饮食"><a href="#饮食" class="headerlink" title="饮食"></a>饮食</h3><pre><code>减肥食谱
    早:全麦面包 + 水煮蛋
    午:蔬菜沙拉
    晚:苹果 + 玉米</code></pre>
<h3 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h3><pre><code>无氧运动：
    仰卧起坐   30个
    平板支撑4组   每组20s
    深蹲       30个
    卷腹 10个

有氧运动
    跑步 30分钟</code></pre>
<h3 id="相信自己"><a href="#相信自己" class="headerlink" title="相信自己"></a>相信自己</h3>]]></content>
      <tags>
        <tag>生活</tag>
        <tag>减肥</tag>
      </tags>
  </entry>
  <entry>
    <title>python 23种常用设计模式和代码示例</title>
    <url>/2020/09/07/python-23%E7%A7%8D%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>模式设计是程序发展过程中解决问题的思路结晶，是无数前辈的心血和总结，也是衡量一个程序员功底的标准之一。同时模式设计是适用于任何一门编程语言的思想。</li>
</ul>
<hr>
<h3 id="模式设计遵守以下几个原则"><a href="#模式设计遵守以下几个原则" class="headerlink" title="模式设计遵守以下几个原则"></a>模式设计遵守以下几个原则</h3><ul>
<li><p>开闭原则（Open Close Principle）</p>
<p>  <code>对扩展开放，对修改关闭。</code></p>
</li>
<li><p>里氏代换原则（Liskov Substitution Principle）</p>
<p>  <code>只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</code></p>
</li>
<li><p>依赖倒转原则（Dependence Inversion Principle）</p>
<p>  <code>这个是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。</code></p>
</li>
<li><p>接口隔离原则（Interface Segregation Principle）</p>
<p>  <code>使用多个隔离的借口来降低耦合度。</code></p>
</li>
<li><p>迪米特法则（Demeter Principle）</p>
<p>  <code>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</code></p>
</li>
<li><p>合成复用原则（Composite Reuse Principle）</p>
<p>  <code>原则是尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。</code></p>
</li>
</ul>
<h3 id="python-23种常用设计模式和代码示例"><a href="#python-23种常用设计模式和代码示例" class="headerlink" title="python 23种常用设计模式和代码示例"></a>python 23种常用设计模式和代码示例</h3><ul>
<li><h4 id="创建型模式5种"><a href="#创建型模式5种" class="headerlink" title="创建型模式5种"></a>创建型模式5种</h4><ul>
<li><p><a href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">工厂模式 &amp;&amp; 抽象工厂模式</a></p>
</li>
<li><p><a href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F">建造者模式</a></p>
</li>
<li><p><a href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">原型模式-快速实例化类的一种途径</a></p>
</li>
<li><p><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式</a></p>
</li>
<li><p><a href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93">创建型模式总结</a></p>
</li>
</ul>
</li>
<li><h4 id="结构型模式7种"><a href="#结构型模式7种" class="headerlink" title="结构型模式7种"></a>结构型模式7种</h4><ul>
<li><p><a href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器模式-各种类接口的合并</a></p>
</li>
<li><p><a href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F">桥接模式</a></p>
</li>
<li><p><a href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F">组合模式</a></p>
</li>
<li><p><a href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F">装饰模式</a></p>
</li>
<li><p><a href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F">外观模式</a></p>
</li>
<li><p><a href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F">享元模式</a></p>
</li>
<li><p><a href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">代理模式</a></p>
</li>
<li><p><a href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93">结构型模式总结</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="行为型模式11种"><a href="#行为型模式11种" class="headerlink" title="行为型模式11种"></a>行为型模式11种</h4><ul>
<li><p><a href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F">解释器模式</a></p>
</li>
<li><p><a href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">模板方法模式</a></p>
</li>
<li><p><a href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F">责任链模式</a></p>
</li>
<li><p><a href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F">命令模式</a></p>
</li>
<li><p><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F">迭代器模式</a></p>
</li>
<li><p><a href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F">中介者模式</a></p>
</li>
<li><p>备忘录模式</p>
</li>
<li><p>观察者模式</p>
</li>
<li><p>状态模式</p>
</li>
<li><p>策略模式</p>
</li>
<li><p>访问者模式</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><ul>
<li><h4 id="工厂模式和抽象工厂模式"><a href="#工厂模式和抽象工厂模式" class="headerlink" title="工厂模式和抽象工厂模式"></a>工厂模式和抽象工厂模式</h4><h5 id="工厂模式-定义一个用于创建对象的接口函数Interface，让子类决定实例化哪一个类A或者B"><a href="#工厂模式-定义一个用于创建对象的接口函数Interface，让子类决定实例化哪一个类A或者B" class="headerlink" title="工厂模式: 定义一个用于创建对象的接口函数Interface，让子类决定实例化哪一个类A或者B"></a>工厂模式: 定义一个用于创建对象的接口函数Interface，让子类决定实例化哪一个类A或者B</h5> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.word = <span class="string">&quot;A&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.word = <span class="string">&quot;B&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Interface</span>(<span class="params">classname</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;工厂模式函数接口</span></span><br><span class="line"><span class="string">        :param classname:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    run = dict(A=A, B=B)</span><br><span class="line">    <span class="keyword">return</span> run[classname]()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test1 = Interface(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    test1.run()</span><br><span class="line"></span><br><span class="line">&gt;&gt; A</span><br></pre></td></tr></table></figure>
<h5 id="抽象工厂模式-创建一系列相关或相互依赖抽象出来的的对象接口Interface，不需要具体指明实例化A类或B类"><a href="#抽象工厂模式-创建一系列相关或相互依赖抽象出来的的对象接口Interface，不需要具体指明实例化A类或B类" class="headerlink" title="抽象工厂模式: 创建一系列相关或相互依赖抽象出来的的对象接口Interface，不需要具体指明实例化A类或B类"></a>抽象工厂模式: 创建一系列相关或相互依赖抽象出来的的对象接口Interface，不需要具体指明实例化A类或B类</h5> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.word = <span class="string">&quot;A&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(self.word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.word = <span class="string">&quot;B&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, classname</span>):</span></span><br><span class="line">        self.test = classname</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.test().run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test1 = Interface(B)</span><br><span class="line">    test1.run()</span><br><span class="line"></span><br><span class="line">&gt;&gt; B</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><h5 id="建造者模式应该有几个关键要素：相同的流程、不同的表示。也就是同一个对象（建筑）在同一修建者组织下，以相同的实例化流程（施工流程）来达到不同的表示效果（毛坯、写字楼）"><a href="#建造者模式应该有几个关键要素：相同的流程、不同的表示。也就是同一个对象（建筑）在同一修建者组织下，以相同的实例化流程（施工流程）来达到不同的表示效果（毛坯、写字楼）" class="headerlink" title="建造者模式应该有几个关键要素：相同的流程、不同的表示。也就是同一个对象（建筑）在同一修建者组织下，以相同的实例化流程（施工流程）来达到不同的表示效果（毛坯、写字楼）"></a>建造者模式应该有几个关键要素：相同的流程、不同的表示。也就是同一个对象（建筑）在同一修建者组织下，以相同的实例化流程（施工流程）来达到不同的表示效果（毛坯、写字楼）</h5> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;建造流程</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.materiel = <span class="literal">None</span></span><br><span class="line">    self.design = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&quot;设计方案：%s | 使用材料：%s&quot;</span> % (self.design, self.materiel))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">Builder</span>):</span></span><br><span class="line">    <span class="string">&quot;方案A&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_materiel</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.materiel = <span class="string">&quot;砖瓦&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_design</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.design = <span class="string">&quot;方案A&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">Builder</span>):</span></span><br><span class="line">    <span class="string">&quot;方案B&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_materiel</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.materiel = <span class="string">&quot;玻璃&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_design</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.design = <span class="string">&quot;方案B&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;组织：买材料-施工&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.programme = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.programme.get_materiel()</span><br><span class="line">        print(<span class="string">&quot;购买材料：&#123;&#125;&quot;</span>.format(self.programme.materiel))</span><br><span class="line">        self.programme.get_design()</span><br><span class="line">        print(<span class="string">&quot;设计方案：&#123;&#125;&quot;</span>.format(self.programme.design))</span><br><span class="line">        self.programme.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test = Director()</span><br><span class="line">    test.programme = A()</span><br><span class="line">    test.build()</span><br><span class="line"></span><br><span class="line">&gt;&gt; 购买材料：砖瓦</span><br><span class="line">&gt;&gt; 设计方案：方案A</span><br><span class="line">&gt;&gt; 设计方案：方案A | 使用材料：砖瓦</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><h5 id="原型是相对于复制、克隆而言，但是不同于模板，模板创造出的东西是一模一样，而原型创造的东西是允许差异化和个性化存在，这就是原型。"><a href="#原型是相对于复制、克隆而言，但是不同于模板，模板创造出的东西是一模一样，而原型创造的东西是允许差异化和个性化存在，这就是原型。" class="headerlink" title="原型是相对于复制、克隆而言，但是不同于模板，模板创造出的东西是一模一样，而原型创造的东西是允许差异化和个性化存在，这就是原型。"></a>原型是相对于复制、克隆而言，但是不同于模板，模板创造出的东西是一模一样，而原型创造的东西是允许差异化和个性化存在，这就是原型。</h5><h5 id="原型模式最为核心的是属性更新，属性更新是类的自有属性-dict-的更新。"><a href="#原型模式最为核心的是属性更新，属性更新是类的自有属性-dict-的更新。" class="headerlink" title="原型模式最为核心的是属性更新，属性更新是类的自有属性__dict__的更新。"></a>原型模式最为核心的是属性更新，属性更新是类的自有属性__dict__的更新。</h5><h5 id="要实现多个人的自我介绍，一般方法是每个人都创建一个对象，但是使用原型模式之后，只需要实例化一个对象（标准人）-后面的人都已这个标准人为基础来实现个性化。"><a href="#要实现多个人的自我介绍，一般方法是每个人都创建一个对象，但是使用原型模式之后，只需要实例化一个对象（标准人）-后面的人都已这个标准人为基础来实现个性化。" class="headerlink" title="要实现多个人的自我介绍，一般方法是每个人都创建一个对象，但是使用原型模式之后，只需要实例化一个对象（标准人）,后面的人都已这个标准人为基础来实现个性化。"></a>要实现多个人的自我介绍，一般方法是每个人都创建一个对象，但是使用原型模式之后，只需要实例化一个对象（标准人）,后面的人都已这个标准人为基础来实现个性化。</h5> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Information</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.name = <span class="literal">None</span></span><br><span class="line">    self.age = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&quot;我的名字叫：&#123;&#125;，我今年&#123;&#125;岁&quot;</span>.format(self.name, self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, _obj</span>):</span></span><br><span class="line">        self.copy_obj = _obj()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self, **attr</span>):</span></span><br><span class="line">        self.copy_obj.__dict__.update(attr)</span><br><span class="line">        <span class="keyword">return</span> self.copy_obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    proto = Prototype(Information)</span><br><span class="line">    test = proto.copy(name=<span class="string">&quot;张三&quot;</span>, age=<span class="number">4</span>)</span><br><span class="line">    test.run()</span><br><span class="line">    test = proto.copy(name=<span class="string">&quot;李四&quot;</span>, age=<span class="number">5</span>)</span><br><span class="line">    test.run()</span><br><span class="line"></span><br><span class="line">&gt;&gt; 我的名字叫：张三，我今年<span class="number">4</span>岁</span><br><span class="line">&gt;&gt; 我的名字叫：李四，我今年<span class="number">5</span>岁</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><h5 id="顾名思义是一个实例，即在一个项目之中，单例的类只实例化一次。它常常应用于数据库操作、日志函数。"><a href="#顾名思义是一个实例，即在一个项目之中，单例的类只实例化一次。它常常应用于数据库操作、日志函数。" class="headerlink" title="顾名思义是一个实例，即在一个项目之中，单例的类只实例化一次。它常常应用于数据库操作、日志函数。"></a>顾名思义是一个实例，即在一个项目之中，单例的类只实例化一次。它常常应用于数据库操作、日志函数。</h5><h5 id="单例的核心在类的内部方法new-，每次实例化都是通过执行new函数来返回实例对象。"><a href="#单例的核心在类的内部方法new-，每次实例化都是通过执行new函数来返回实例对象。" class="headerlink" title="单例的核心在类的内部方法new()，每次实例化都是通过执行new函数来返回实例对象。"></a>单例的核心在类的内部方法<strong>new</strong>()，每次实例化都是通过执行new函数来返回实例对象。</h5><h5 id="单例就是在类里面定义一个作用域最高的标志性的属性，如果实例化过一次，那这个属性为True否则为False，那么返回上次实例化的对象"><a href="#单例就是在类里面定义一个作用域最高的标志性的属性，如果实例化过一次，那这个属性为True否则为False，那么返回上次实例化的对象" class="headerlink" title="单例就是在类里面定义一个作用域最高的标志性的属性，如果实例化过一次，那这个属性为True否则为False，那么返回上次实例化的对象"></a>单例就是在类里面定义一个作用域最高的标志性的属性，如果实例化过一次，那这个属性为True否则为False，那么返回上次实例化的对象</h5> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params">object</span>):</span></span><br><span class="line">__instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kw</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cls.__instance:</span><br><span class="line">        cls.__instance = super().__new__(cls, *args, **kw)</span><br><span class="line">    <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test = Singleton()</span><br><span class="line">    test1 = Singleton()</span><br><span class="line">    print(id(test), id(test1))</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="number">1892554713744</span> <span class="number">1892554713744</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="创建型模式总结"><a href="#创建型模式总结" class="headerlink" title="创建型模式总结"></a>创建型模式总结</h4><ul>
<li><p>他们之所以属于创建型，在于他们控制或者影响一个实例化对象的创建过称。</p>
</li>
<li><p>工厂方法和抽象工厂控制实例对象时候的类选择，建造者模式控制多个类以相同的流程实例化、原型模式通过深度复制原型类让类的多个实例化更加的迅速，单例模式让类的实例化对象只存在一个。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><h5 id="核心思想是创建一个适配器类，通过-dict-将需要转化的类的方法注册到适配器，复写-getattr-使其在适配器函数查无方法的时候，执行getattr魔法方法。"><a href="#核心思想是创建一个适配器类，通过-dict-将需要转化的类的方法注册到适配器，复写-getattr-使其在适配器函数查无方法的时候，执行getattr魔法方法。" class="headerlink" title="核心思想是创建一个适配器类，通过__dict__将需要转化的类的方法注册到适配器，复写__getattr__使其在适配器函数查无方法的时候，执行getattr魔法方法。"></a>核心思想是创建一个适配器类，通过__dict__将需要转化的类的方法注册到适配器，复写__getattr__使其在适配器函数查无方法的时候，执行getattr魔法方法。</h5>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class A(object):</span><br><span class="line">def a(self):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是a方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class B(object):</span><br><span class="line">    def b(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这是b方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class C(object):</span><br><span class="line">    def c(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这是c方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Adapter(object):</span><br><span class="line">    def __init__(self, classname, method):</span><br><span class="line">        self.classname = classname</span><br><span class="line">        self.__dict__.update(method)</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, attr):</span><br><span class="line">        <span class="built_in">return</span> getattr(self.classname, attr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">test</span>():</span><br><span class="line">    objects = []</span><br><span class="line">    AA = A()</span><br><span class="line">    objects.append(Adapter(AA, dict(<span class="built_in">test</span>=AA.a)))</span><br><span class="line">    BB = B()</span><br><span class="line">    objects.append(Adapter(BB, dict(<span class="built_in">test</span>=BB.b)))</span><br><span class="line">    CC = C()</span><br><span class="line">    objects.append(Adapter(CC, dict(<span class="built_in">test</span>=CC.c)))</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> objects:</span><br><span class="line">        obj.test()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">test</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; 这是a方法</span><br><span class="line">&gt;&gt; 这是b方法</span><br><span class="line">&gt;&gt; 这是c方法</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><h5 id="Python程序设计中的桥接指的是抽象部分和实体部分的连接，简单来说是类和类实例化过称中的连接。"><a href="#Python程序设计中的桥接指的是抽象部分和实体部分的连接，简单来说是类和类实例化过称中的连接。" class="headerlink" title="Python程序设计中的桥接指的是抽象部分和实体部分的连接，简单来说是类和类实例化过称中的连接。"></a>Python程序设计中的桥接指的是抽象部分和实体部分的连接，简单来说是类和类实例化过称中的连接。</h5><h5 id="桥接模式通过在类和类实例化中间作用，使其抽象和实现可以独立变化而不互相干扰，这就是桥接模式最大的作用。"><a href="#桥接模式通过在类和类实例化中间作用，使其抽象和实现可以独立变化而不互相干扰，这就是桥接模式最大的作用。" class="headerlink" title="桥接模式通过在类和类实例化中间作用，使其抽象和实现可以独立变化而不互相干扰，这就是桥接模式最大的作用。"></a>桥接模式通过在类和类实例化中间作用，使其抽象和实现可以独立变化而不互相干扰，这就是桥接模式最大的作用。</h5><h5 id="核心的思想是通过封装，将一个抽象类的相关参数和方法分别作为桥接类的属性，这样在实例化桥接类后通过修改桥接类的属性，便可以实现抽象和实现之间的独立变化。"><a href="#核心的思想是通过封装，将一个抽象类的相关参数和方法分别作为桥接类的属性，这样在实例化桥接类后通过修改桥接类的属性，便可以实现抽象和实现之间的独立变化。" class="headerlink" title="核心的思想是通过封装，将一个抽象类的相关参数和方法分别作为桥接类的属性，这样在实例化桥接类后通过修改桥接类的属性，便可以实现抽象和实现之间的独立变化。"></a>核心的思想是通过封装，将一个抽象类的相关参数和方法分别作为桥接类的属性，这样在实例化桥接类后通过修改桥接类的属性，便可以实现抽象和实现之间的独立变化。</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        print(<span class="string">&quot;my name is &#123;&#125;&quot;</span>.format(name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        print(<span class="string">&quot;我的名字是&#123;&#125;&quot;</span>.format(name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bridge</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, classname, arg</span>):</span></span><br><span class="line">        self.classname = classname</span><br><span class="line">        self.arg = arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bridge_run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.classname.run(self.arg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test = Bridge(A(), <span class="string">&quot;小明&quot;</span>)</span><br><span class="line">    test.bridge_run()</span><br><span class="line">    test.arg = <span class="string">&quot;小王&quot;</span></span><br><span class="line">    test.bridge_run()</span><br><span class="line">    test = Bridge(B(), <span class="string">&quot;小明&quot;</span>)</span><br><span class="line">    test.bridge_run()</span><br><span class="line">    test.arg = <span class="string">&quot;小王&quot;</span></span><br><span class="line">    test.bridge_run()</span><br><span class="line"></span><br><span class="line">&gt;&gt; my name <span class="keyword">is</span> 小明</span><br><span class="line">&gt;&gt; my name <span class="keyword">is</span> 小王</span><br><span class="line">&gt;&gt; 我的名字是小明</span><br><span class="line">&gt;&gt; 我的名字是小王</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><h5 id="组合，将对象组合成树状结构，来表示业务逻辑上的-部分-整体-层次，这种组合使单个对象和组合对象的使用方法一样。"><a href="#组合，将对象组合成树状结构，来表示业务逻辑上的-部分-整体-层次，这种组合使单个对象和组合对象的使用方法一样。" class="headerlink" title="组合，将对象组合成树状结构，来表示业务逻辑上的[部分-整体]层次，这种组合使单个对象和组合对象的使用方法一样。"></a>组合，将对象组合成树状结构，来表示业务逻辑上的[部分-整体]层次，这种组合使单个对象和组合对象的使用方法一样。</h5> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Componentbase</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>(<span class="params">Componentbase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, duty</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.duty = duty</span><br><span class="line">        self.children = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        self.children.append(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        self.children.remove(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self, n=<span class="number">1</span></span>):</span></span><br><span class="line">        print(<span class="string">&quot;部门：&#123;&#125;，级别：&#123;&#125;，职责：&#123;&#125;&quot;</span>.format(self.name, n, self.duty))</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> obj <span class="keyword">in</span> self.children:</span><br><span class="line">            obj.display(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    root = node(<span class="string">&quot;总经理办公室&quot;</span>, <span class="string">&quot;总经理&quot;</span>)</span><br><span class="line">    node1 = node(<span class="string">&quot;财务部门&quot;</span>, <span class="string">&quot;公司财务管理&quot;</span>)</span><br><span class="line">    root.add(node1)</span><br><span class="line">    node2 = node(<span class="string">&quot;生产部门&quot;</span>, <span class="string">&quot;生产产品&quot;</span>)</span><br><span class="line">    root.add(node1)</span><br><span class="line">    node3 = node(<span class="string">&quot;业务部门&quot;</span>, <span class="string">&quot;销售产品&quot;</span>)</span><br><span class="line">    root.add(node3)</span><br><span class="line">    node4 = node(<span class="string">&quot;销售事业一部门&quot;</span>, <span class="string">&quot;A产品销售&quot;</span>)</span><br><span class="line">    node3.add(node4)</span><br><span class="line">    root.display()</span><br><span class="line"></span><br><span class="line">&gt;&gt; 部门：总经理办公室，级别：<span class="number">1</span>，职责：总经理</span><br><span class="line">&gt;&gt; 部门：财务部门，级别：<span class="number">2</span>，职责：公司财务管理</span><br><span class="line">&gt;&gt; 部门：财务部门，级别：<span class="number">2</span>，职责：公司财务管理</span><br><span class="line">&gt;&gt; 部门：业务部门，级别：<span class="number">2</span>，职责：销售产品</span><br><span class="line">&gt;&gt; 部门：销售事业一部门，级别：<span class="number">3</span>，职责：A产品销售</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h4><h5 id="装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。"><a href="#装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。" class="headerlink" title="装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。"></a>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</h5><h5 id="在Python种实现动态扩展对象功能的方法，最简单的是通过复写-getattr-函数，在getattr中写入我们需要扩展的功能，实例代码如下："><a href="#在Python种实现动态扩展对象功能的方法，最简单的是通过复写-getattr-函数，在getattr中写入我们需要扩展的功能，实例代码如下：" class="headerlink" title="在Python种实现动态扩展对象功能的方法，最简单的是通过复写__getattr__函数，在getattr中写入我们需要扩展的功能，实例代码如下："></a>在Python种实现动态扩展对象功能的方法，最简单的是通过复写__getattr__函数，在getattr中写入我们需要扩展的功能，实例代码如下：</h5> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;添加数据&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;删除数据&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, fuc</span>):</span></span><br><span class="line">        self.fuc = fuc</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;保存数据&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self.fuc, item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test = Decorator(Test())</span><br><span class="line">    test.add()</span><br><span class="line">    test.remove()</span><br><span class="line">    test.save()</span><br><span class="line"></span><br><span class="line">&gt;&gt; 添加数据</span><br><span class="line">&gt;&gt; 删除数据</span><br><span class="line">&gt;&gt; 保存数据</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><h5 id="外观模式（Facade），亦称“过程模式”，-为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。"><a href="#外观模式（Facade），亦称“过程模式”，-为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。" class="headerlink" title="外观模式（Facade），亦称“过程模式”， 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。"></a>外观模式（Facade），亦称“过程模式”， 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</h5><h5 id="与接口相关的适配器模式有所不同的是外观模式是为大系统下的小系统设计统一的接口，而适配器模式是针对不同系统各种接口调用而设计。"><a href="#与接口相关的适配器模式有所不同的是外观模式是为大系统下的小系统设计统一的接口，而适配器模式是针对不同系统各种接口调用而设计。" class="headerlink" title="与接口相关的适配器模式有所不同的是外观模式是为大系统下的小系统设计统一的接口，而适配器模式是针对不同系统各种接口调用而设计。"></a>与接口相关的适配器模式有所不同的是外观模式是为大系统下的小系统设计统一的接口，而适配器模式是针对不同系统各种接口调用而设计。</h5> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&quot;保存a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;删除a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;保存b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;删除b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._api1 = A()</span><br><span class="line">        self._api2 = B()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>):</span></span><br><span class="line">        [obj.save() <span class="keyword">for</span> obj <span class="keyword">in</span> [self._api1, self._api2]]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self</span>):</span></span><br><span class="line">        [obj.remove() <span class="keyword">for</span> obj <span class="keyword">in</span> [self._api1, self._api2]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test = Facade()</span><br><span class="line">    test.save()</span><br><span class="line">    test.remove()</span><br><span class="line"></span><br><span class="line">&gt;&gt; 保存a</span><br><span class="line">&gt;&gt; 保存b</span><br><span class="line">&gt;&gt; 删除a</span><br><span class="line">&gt;&gt; 删除b</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><h5 id="元，可理解为python中的元类、最小粒度的类，系统中存在大量的相似对象时，可以选择享元模式提高资源利用率。"><a href="#元，可理解为python中的元类、最小粒度的类，系统中存在大量的相似对象时，可以选择享元模式提高资源利用率。" class="headerlink" title="元，可理解为python中的元类、最小粒度的类，系统中存在大量的相似对象时，可以选择享元模式提高资源利用率。"></a>元，可理解为python中的元类、最小粒度的类，系统中存在大量的相似对象时，可以选择享元模式提高资源利用率。</h5><h5 id="在这个案例中共享了报价过程的类Flyweight，同一种产品类型的报价过程只会实例化一次，这就是享元模式最核心的要义：共享业务逻辑上的最小单元。"><a href="#在这个案例中共享了报价过程的类Flyweight，同一种产品类型的报价过程只会实例化一次，这就是享元模式最核心的要义：共享业务逻辑上的最小单元。" class="headerlink" title="在这个案例中共享了报价过程的类Flyweight，同一种产品类型的报价过程只会实例化一次，这就是享元模式最核心的要义：共享业务逻辑上的最小单元。"></a>在这个案例中共享了报价过程的类Flyweight，同一种产品类型的报价过程只会实例化一次，这就是享元模式最核心的要义：共享业务逻辑上的最小单元。</h5><h5 id="如果一个应用程序使用了大量的对象，而这些对象造成了很大的存储开销的时候就可以考虑是否可以使用享元模式。"><a href="#如果一个应用程序使用了大量的对象，而这些对象造成了很大的存储开销的时候就可以考虑是否可以使用享元模式。" class="headerlink" title="如果一个应用程序使用了大量的对象，而这些对象造成了很大的存储开销的时候就可以考虑是否可以使用享元模式。"></a>如果一个应用程序使用了大量的对象，而这些对象造成了很大的存储开销的时候就可以考虑是否可以使用享元模式。</h5> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_price</span>(<span class="params">self, price</span>):</span></span><br><span class="line">        print(<span class="string">&quot;产品类型&#123;&#125;：详情：&#123;&#125;&quot;</span>.format(self.name, price))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryFlyweight</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.product = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_product</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.product.get(key):</span><br><span class="line">            self.product[key] = Flyweight(key)</span><br><span class="line">        <span class="keyword">return</span> self.product[key]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test = FactoryFlyweight()</span><br><span class="line">    a = test.get_product(<span class="string">&quot;高端&quot;</span>)</span><br><span class="line">    a.get_price(<span class="string">&quot;lv : 1000&quot;</span>)</span><br><span class="line">    a.get_price(<span class="string">&quot;iphone11: 8000&quot;</span>)</span><br><span class="line">    b = test.get_product(<span class="string">&quot;低端&quot;</span>)</span><br><span class="line">    b.get_price(<span class="string">&quot;拖鞋 : 5&quot;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt; 产品类型-高端：详情：lv : <span class="number">1000</span></span><br><span class="line">&gt;&gt; 产品类型-高端：详情：iphone11: <span class="number">8000</span></span><br><span class="line">&gt;&gt; 产品类型-低端：详情：拖鞋 : <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><h5 id="代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。"><a href="#代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。" class="headerlink" title="代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。"></a>代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</h5><h5 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h5><ul>
<li><h6 id="远程（Remote）代理：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是在本机器中，也可是在另一台机器中。远程代理又叫做大使（Ambassador）。好处是系统可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。"><a href="#远程（Remote）代理：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是在本机器中，也可是在另一台机器中。远程代理又叫做大使（Ambassador）。好处是系统可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。" class="headerlink" title="远程（Remote）代理：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是在本机器中，也可是在另一台机器中。远程代理又叫做大使（Ambassador）。好处是系统可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。"></a>远程（Remote）代理：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是在本机器中，也可是在另一台机器中。远程代理又叫做大使（Ambassador）。好处是系统可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。</h6></li>
<li><h6 id="虚拟（Virtual）代理（图片延迟加载的例子）：根据需要创建一个资源消耗较大的对象，使得此对象只在需要时才会被真正创建。使用虚拟代理模式的好处就是代理对象可以在必要的时候才将被代理的对象加载；代理可以对加载的过程加以必要的优化。当一个模块的加载十分耗费资源的情况下，虚拟代理的好处就非常明显。"><a href="#虚拟（Virtual）代理（图片延迟加载的例子）：根据需要创建一个资源消耗较大的对象，使得此对象只在需要时才会被真正创建。使用虚拟代理模式的好处就是代理对象可以在必要的时候才将被代理的对象加载；代理可以对加载的过程加以必要的优化。当一个模块的加载十分耗费资源的情况下，虚拟代理的好处就非常明显。" class="headerlink" title="虚拟（Virtual）代理（图片延迟加载的例子）：根据需要创建一个资源消耗较大的对象，使得此对象只在需要时才会被真正创建。使用虚拟代理模式的好处就是代理对象可以在必要的时候才将被代理的对象加载；代理可以对加载的过程加以必要的优化。当一个模块的加载十分耗费资源的情况下，虚拟代理的好处就非常明显。"></a>虚拟（Virtual）代理（图片延迟加载的例子）：根据需要创建一个资源消耗较大的对象，使得此对象只在需要时才会被真正创建。使用虚拟代理模式的好处就是代理对象可以在必要的时候才将被代理的对象加载；代理可以对加载的过程加以必要的优化。当一个模块的加载十分耗费资源的情况下，虚拟代理的好处就非常明显。</h6></li>
<li><h6 id="保护代理（Protection-Proxy-）控制对原始对象的访问。保护代理用于对象应该有不同-的访问权限的时候"><a href="#保护代理（Protection-Proxy-）控制对原始对象的访问。保护代理用于对象应该有不同-的访问权限的时候" class="headerlink" title="保护代理（Protection Proxy ）控制对原始对象的访问。保护代理用于对象应该有不同 的访问权限的时候"></a>保护代理（Protection Proxy ）控制对原始对象的访问。保护代理用于对象应该有不同 的访问权限的时候</h6></li>
<li><h6 id="智能引用（Smart-Reference）代理：当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等"><a href="#智能引用（Smart-Reference）代理：当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等" class="headerlink" title="智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等"></a>智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Purview</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level1</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&quot;权限1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level2</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&quot;权限2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level3</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&quot;权限3&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self._level = Purview()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_level</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.name == <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self._level.level1()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> self.name == <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self._level.level2()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> self.name == <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self._level.level3()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;无权限&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    proxy = Proxy(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    proxy.get_level()</span><br><span class="line">    proxy.name = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    proxy.get_level()</span><br><span class="line">    proxy.name = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">    proxy.get_level()</span><br><span class="line"></span><br><span class="line">&gt;&gt; 权限<span class="number">1</span></span><br><span class="line">&gt;&gt; 权限<span class="number">2</span></span><br><span class="line">&gt;&gt; 权限<span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="结构型模式总结"><a href="#结构型模式总结" class="headerlink" title="结构型模式总结"></a>结构型模式总结</h4><ul>
<li><h5 id="常用的结构型模式为：适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式，结构型的意思是处理类与类之间、系统与系统之间的逻辑结构，是协调类结构的重要模式设计思想。"><a href="#常用的结构型模式为：适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式，结构型的意思是处理类与类之间、系统与系统之间的逻辑结构，是协调类结构的重要模式设计思想。" class="headerlink" title="常用的结构型模式为：适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式，结构型的意思是处理类与类之间、系统与系统之间的逻辑结构，是协调类结构的重要模式设计思想。"></a>常用的结构型模式为：适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式，结构型的意思是处理类与类之间、系统与系统之间的逻辑结构，是协调类结构的重要模式设计思想。</h5><p>  适配器模式：将其他类或系统中的方法封装一个统一接口来调用，从而达到适配各种系统方法的目的。</p>
<p>  桥接模式：处理抽象部分（类）与实体（实例化）之间的结构，可以使抽象部分和实例化部分单独变化不干扰。</p>
<p>  组合模式：用于设计一个有层次等级的系统，处理各层次之间的关系。</p>
<p>  装饰模式：用于扩展一个类或者系统的功能</p>
<p>  外观模式：为子系统中相似功能设计一组统一的界面</p>
<p>  享元模式：让小粒度高频使用的类被共享，减少实例化过程，减少损耗</p>
<p>  代理模式：用于控制一个对象的访问，让客户端通过代理访问，而不是直接访问</p>
</li>
<li><h5 id="总而言之：结构型模式设计用于处理系统之间、类之间的关系，创建型模式用于处理一个实例化过程中类的选择和处理。"><a href="#总而言之：结构型模式设计用于处理系统之间、类之间的关系，创建型模式用于处理一个实例化过程中类的选择和处理。" class="headerlink" title="总而言之：结构型模式设计用于处理系统之间、类之间的关系，创建型模式用于处理一个实例化过程中类的选择和处理。"></a>总而言之：结构型模式设计用于处理系统之间、类之间的关系，创建型模式用于处理一个实例化过程中类的选择和处理。</h5></li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><h5 id="开发者自定义一种“有内涵”的语言（或者叫字符串），并设定相关的解释规则，输入该字符串后可以输出公认的解释，或者执行程序可以理解的动作。这种模式被用在-SQL-解析、符号处理引擎等"><a href="#开发者自定义一种“有内涵”的语言（或者叫字符串），并设定相关的解释规则，输入该字符串后可以输出公认的解释，或者执行程序可以理解的动作。这种模式被用在-SQL-解析、符号处理引擎等" class="headerlink" title="开发者自定义一种“有内涵”的语言（或者叫字符串），并设定相关的解释规则，输入该字符串后可以输出公认的解释，或者执行程序可以理解的动作。这种模式被用在 SQL 解析、符号处理引擎等"></a>开发者自定义一种“有内涵”的语言（或者叫字符串），并设定相关的解释规则，输入该字符串后可以输出公认的解释，或者执行程序可以理解的动作。这种模式被用在 SQL 解析、符号处理引擎等</h5> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Code</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, text=None</span>):</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, code</span>):</span></span><br><span class="line">        code = code.text</span><br><span class="line">        code_dict = &#123;</span><br><span class="line">            <span class="string">&#x27;获取当前时间戳&#x27;</span>: time.time(), <span class="string">&quot;获取当前日期&quot;</span>: datetime.datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        print(code_dict.get(code))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    code = Code()</span><br><span class="line">    code.text = <span class="string">&quot;获取当前时间戳&quot;</span></span><br><span class="line">    Interpreter().run(code)</span><br><span class="line">    code.text = <span class="string">&quot;获取当前日期&quot;</span></span><br><span class="line">    Interpreter().run(code)</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="number">1600134822.805664</span></span><br><span class="line">&gt;&gt; <span class="number">2020</span><span class="number">-09</span><span class="number">-15</span> <span class="number">09</span>:<span class="number">53</span>:<span class="number">42</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><h5 id="定义一个算法或者流程，部分环节设计为外部可变，用类似于模板的思想来实例化一个实体，可以往模板中填充不同的内容；在模板思想下，实体的整体框架是确定的，他是一个模板，但是模板下内容可变，从而实现了动态的更新流程或算法。"><a href="#定义一个算法或者流程，部分环节设计为外部可变，用类似于模板的思想来实例化一个实体，可以往模板中填充不同的内容；在模板思想下，实体的整体框架是确定的，他是一个模板，但是模板下内容可变，从而实现了动态的更新流程或算法。" class="headerlink" title="定义一个算法或者流程，部分环节设计为外部可变，用类似于模板的思想来实例化一个实体，可以往模板中填充不同的内容；在模板思想下，实体的整体框架是确定的，他是一个模板，但是模板下内容可变，从而实现了动态的更新流程或算法。"></a>定义一个算法或者流程，部分环节设计为外部可变，用类似于模板的思想来实例化一个实体，可以往模板中填充不同的内容；在模板思想下，实体的整体框架是确定的，他是一个模板，但是模板下内容可变，从而实现了动态的更新流程或算法。</h5><h5 id="建造者模式是将对象的构建和表示分离，相同的构建生成不同的表示对象，而模板方法是将定义的算法或流程中的部分环节推迟到子类中实现算法或流程的可变，这是二者本质的区别。"><a href="#建造者模式是将对象的构建和表示分离，相同的构建生成不同的表示对象，而模板方法是将定义的算法或流程中的部分环节推迟到子类中实现算法或流程的可变，这是二者本质的区别。" class="headerlink" title="建造者模式是将对象的构建和表示分离，相同的构建生成不同的表示对象，而模板方法是将定义的算法或流程中的部分环节推迟到子类中实现算法或流程的可变，这是二者本质的区别。"></a>建造者模式是将对象的构建和表示分离，相同的构建生成不同的表示对象，而模板方法是将定义的算法或流程中的部分环节推迟到子类中实现算法或流程的可变，这是二者本质的区别。</h5> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, number</span>):</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.number = number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handle</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, user=None</span>):</span></span><br><span class="line">        self.user = user</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invoicen</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;姓名：&#123;&#125;， 数量：&#123;&#125;&#x27;</span>.format(self.user.name, self.user.number))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;制作完成&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.invoicen()</span><br><span class="line">        self.make()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test = Handle()</span><br><span class="line">    test.user = User(<span class="string">&#x27;小明&#x27;</span>, <span class="number">5</span>)</span><br><span class="line">    test.run()</span><br><span class="line">    test.user = User(<span class="string">&#x27;小望&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">    test.run()</span><br><span class="line"></span><br><span class="line">&gt;&gt; 姓名：小明， 数量：<span class="number">5</span></span><br><span class="line">&gt;&gt; 制作完成</span><br><span class="line">&gt;&gt; 姓名：小望， 数量：<span class="number">3</span></span><br><span class="line">&gt;&gt; 制作完成</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><h5 id="将多个处理方法连接成一条链条，请求将在这条链条上流动直到该链条中有一个节点可以处理该请求；通常这条链条是一个对象包含对另一个对象的引用而形成链条，每个节点有对请求的条件，当不满足条件将传递给下一个节点处理。"><a href="#将多个处理方法连接成一条链条，请求将在这条链条上流动直到该链条中有一个节点可以处理该请求；通常这条链条是一个对象包含对另一个对象的引用而形成链条，每个节点有对请求的条件，当不满足条件将传递给下一个节点处理。" class="headerlink" title="将多个处理方法连接成一条链条，请求将在这条链条上流动直到该链条中有一个节点可以处理该请求；通常这条链条是一个对象包含对另一个对象的引用而形成链条，每个节点有对请求的条件，当不满足条件将传递给下一个节点处理。"></a>将多个处理方法连接成一条链条，请求将在这条链条上流动直到该链条中有一个节点可以处理该请求；通常这条链条是一个对象包含对另一个对象的引用而形成链条，每个节点有对请求的条件，当不满足条件将传递给下一个节点处理。</h5><h5 id="责任链模式有几个要点："><a href="#责任链模式有几个要点：" class="headerlink" title="责任链模式有几个要点："></a>责任链模式有几个要点：</h5><ul>
<li><h6 id="一个对象中含有另一个对象的引用以此类推形成链条"><a href="#一个对象中含有另一个对象的引用以此类推形成链条" class="headerlink" title="一个对象中含有另一个对象的引用以此类推形成链条"></a>一个对象中含有另一个对象的引用以此类推形成链条</h6></li>
<li><h6 id="每个对象中应该有明确的责任划分即处理请求的条件"><a href="#每个对象中应该有明确的责任划分即处理请求的条件" class="headerlink" title="每个对象中应该有明确的责任划分即处理请求的条件"></a>每个对象中应该有明确的责任划分即处理请求的条件</h6></li>
<li><h6 id="链条的最后一节应该设计成通用请求处理，以免出现漏洞"><a href="#链条的最后一节应该设计成通用请求处理，以免出现漏洞" class="headerlink" title="链条的最后一节应该设计成通用请求处理，以免出现漏洞"></a>链条的最后一节应该设计成通用请求处理，以免出现漏洞</h6></li>
<li><h6 id="请求应该传入链条的头部"><a href="#请求应该传入链条的头部" class="headerlink" title="请求应该传入链条的头部"></a>请求应该传入链条的头部</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, obj=None</span>):</span></span><br><span class="line">    self.obj = obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">screen</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="keyword">if</span> number &gt;= <span class="number">200</span>:</span><br><span class="line">            print(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.obj.screen(number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">screen</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">200</span> &gt;= number &gt;= <span class="number">100</span>:</span><br><span class="line">            print(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.obj.screen(number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">screen</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">100</span>:</span><br><span class="line">            print(<span class="string">&quot;c&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    c = C()</span><br><span class="line">    b = B(c)</span><br><span class="line">    a = A(b)</span><br><span class="line">    list = [<span class="number">500</span>, <span class="number">156</span>, <span class="number">30</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> list:</span><br><span class="line">        a.screen(i)</span><br><span class="line"></span><br><span class="line">&gt;&gt; a</span><br><span class="line">&gt;&gt; b</span><br><span class="line">&gt;&gt; c</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><h5 id="“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销-重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。这就是命令模式（Command-Pattern）"><a href="#“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销-重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。这就是命令模式（Command-Pattern）" class="headerlink" title="“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。这就是命令模式（Command Pattern）"></a>“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。这就是命令模式（Command Pattern）</h5><h5 id="命令模式的几个核心角色及其分工："><a href="#命令模式的几个核心角色及其分工：" class="headerlink" title="命令模式的几个核心角色及其分工："></a>命令模式的几个核心角色及其分工：</h5><ul>
<li><h6 id="Command（命令基类）：主要声明抽象命令类的接口"><a href="#Command（命令基类）：主要声明抽象命令类的接口" class="headerlink" title="Command（命令基类）：主要声明抽象命令类的接口"></a>Command（命令基类）：主要声明抽象命令类的接口</h6></li>
<li><h6 id="ConcreteCommand（命令实现）：复写基类中声明的接口，实现具体的调用功能"><a href="#ConcreteCommand（命令实现）：复写基类中声明的接口，实现具体的调用功能" class="headerlink" title="ConcreteCommand（命令实现）：复写基类中声明的接口，实现具体的调用功能"></a>ConcreteCommand（命令实现）：复写基类中声明的接口，实现具体的调用功能</h6></li>
<li><h6 id="Receiver（命令的内容）：具体执行动作的对象"><a href="#Receiver（命令的内容）：具体执行动作的对象" class="headerlink" title="Receiver（命令的内容）：具体执行动作的对象"></a>Receiver（命令的内容）：具体执行动作的对象</h6></li>
<li><h6 id="Invoker-命令调度和执行-：全部命令的执行和调度入口"><a href="#Invoker-命令调度和执行-：全部命令的执行和调度入口" class="headerlink" title="Invoker(命令调度和执行)：全部命令的执行和调度入口"></a>Invoker(命令调度和执行)：全部命令的执行和调度入口</h6></li>
<li><h6 id="Client（命令装配者）-创建具体的命令对象，组装命令对象和接收者"><a href="#Client（命令装配者）-创建具体的命令对象，组装命令对象和接收者" class="headerlink" title="Client（命令装配者）:创建具体的命令对象，组装命令对象和接收者"></a>Client（命令装配者）:创建具体的命令对象，组装命令对象和接收者</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">    self.obj = obj</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span>(<span class="params">Command</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.obj.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.commands = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, cmd</span>):</span></span><br><span class="line">        self.commands.append(cmd)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, cmd</span>):</span></span><br><span class="line">        self.commands.remove(cmd)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_command</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> cmd <span class="keyword">in</span> self.commands:</span><br><span class="line">            cmd.execute()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, word</span>):</span></span><br><span class="line">        self.word = word</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test = Invoker()</span><br><span class="line">    cmd1 = ConcreteCommand(Receiver(<span class="string">&#x27;命令1&#x27;</span>))</span><br><span class="line">    test.add(cmd1)</span><br><span class="line">    cmd2 = ConcreteCommand(Receiver(<span class="string">&#x27;命令2&#x27;</span>))</span><br><span class="line">    test.add(cmd2)</span><br><span class="line">    test.run_command()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; 命令<span class="number">1</span></span><br><span class="line">&gt;&gt; 命令<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><h5 id="迭代模式：对外提供一个接口，实现顺序访问聚合数据，但是不显示该数据的内部机制。这就是Python中大名鼎鼎的迭代器。"><a href="#迭代模式：对外提供一个接口，实现顺序访问聚合数据，但是不显示该数据的内部机制。这就是Python中大名鼎鼎的迭代器。" class="headerlink" title="迭代模式：对外提供一个接口，实现顺序访问聚合数据，但是不显示该数据的内部机制。这就是Python中大名鼎鼎的迭代器。"></a>迭代模式：对外提供一个接口，实现顺序访问聚合数据，但是不显示该数据的内部机制。这就是Python中大名鼎鼎的迭代器。</h5> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FibonacciSequence</span>(<span class="params">n</span>):</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line">y = <span class="number">1</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; n:</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    x, y = y, x + y</span><br><span class="line">    <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test = FibonacciSequence(<span class="number">5</span>)</span><br><span class="line">    print(next(test))</span><br><span class="line">    print(next(test))</span><br><span class="line">    print(next(test))</span><br><span class="line">    print(next(test))</span><br><span class="line">    print(next(test))</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="number">1</span></span><br><span class="line">&gt;&gt; <span class="number">1</span></span><br><span class="line">&gt;&gt; <span class="number">2</span></span><br><span class="line">&gt;&gt; <span class="number">3</span></span><br><span class="line">&gt;&gt; <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><h5 id="将其他对象之间的交互装在中介者对象中，达到松耦合、隐式引用、独立变化，与代理模式有相似之感《python设计模式（十一）：代理模式模式》，但是代理模式是结构性模式，侧重于对对象调用的接口控制，而中介者模式是行为性模式，解决对象与对象之间相互调用的行为问题。"><a href="#将其他对象之间的交互装在中介者对象中，达到松耦合、隐式引用、独立变化，与代理模式有相似之感《python设计模式（十一）：代理模式模式》，但是代理模式是结构性模式，侧重于对对象调用的接口控制，而中介者模式是行为性模式，解决对象与对象之间相互调用的行为问题。" class="headerlink" title="将其他对象之间的交互装在中介者对象中，达到松耦合、隐式引用、独立变化，与代理模式有相似之感《python设计模式（十一）：代理模式模式》，但是代理模式是结构性模式，侧重于对对象调用的接口控制，而中介者模式是行为性模式，解决对象与对象之间相互调用的行为问题。"></a>将其他对象之间的交互装在中介者对象中，达到松耦合、隐式引用、独立变化，与代理模式有相似之感《python设计模式（十一）：代理模式模式》，但是代理模式是结构性模式，侧重于对对象调用的接口控制，而中介者模式是行为性模式，解决对象与对象之间相互调用的行为问题。</h5><h5 id="使用场景：-1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。-2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。"><a href="#使用场景：-1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。-2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。" class="headerlink" title="使用场景： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。"></a>使用场景： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</h5><h5 id="注意事项：不应当在职责混乱的时候使用。"><a href="#注意事项：不应当在职责混乱的时候使用。" class="headerlink" title="注意事项：不应当在职责混乱的时候使用。"></a>注意事项：不应当在职责混乱的时候使用。</h5> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, product, price</span>):</span></span><br><span class="line">    self.name = <span class="string">&quot;消费者&quot;</span></span><br><span class="line">    self.product = product</span><br><span class="line">    self.price = price</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shopping</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&quot;我是&#123;&#125;，购买了&#123;&#125;：&#123;&#125;元&quot;</span>.format(self.name, self.product, self.price))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, product, price</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;生产者&quot;</span></span><br><span class="line">        self.product = product</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sale</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;我是&#123;&#125;，出厂了&#123;&#125;：&#123;&#125;元&quot;</span>.format(self.name, self.product, self.price))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mediator</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;中介&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;销售&quot;</span></span><br><span class="line">        self.consumer = <span class="literal">None</span></span><br><span class="line">        self.producer = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">purchase</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;进货&#x27;</span></span><br><span class="line">        self.producer.sale()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sale</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;出货&#x27;</span></span><br><span class="line">        self.consumer.shopping()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">profit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;利润&#x27;</span></span><br><span class="line">        print(<span class="string">&quot;我是&#123;&#125;，我赚了&#123;&#125;元&quot;</span>.format(</span><br><span class="line">            self.name, self.consumer.price - self.producer.price))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">complete</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.purchase()</span><br><span class="line">        self.sale()</span><br><span class="line">        self.profit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    producer = Producer(<span class="string">&quot;手机&quot;</span>, <span class="number">1000</span>)</span><br><span class="line">    consumer = Consumer(<span class="string">&quot;手机&quot;</span>, <span class="number">1500</span>)</span><br><span class="line">    test = Mediator()</span><br><span class="line">    test.consumer = consumer</span><br><span class="line">    test.producer = producer</span><br><span class="line">    test.complete()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 核心技术与实现原理</title>
    <url>/2020/09/02/docker-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一直使用docker，极大的便利了程序的部署，不用为环境发愁。但是一直没有了解docker是如何实现的，底层原理是什么，为什么可以和宿主机分开，为什么可以有自己独立的端口，他和虚拟机有什么区别</p>
<p>看了这篇文章才懂 <a href="http://dockone.io/article/2941">文章链接</a></p>
<h3 id="和虚拟机的区别是什么"><a href="#和虚拟机的区别是什么" class="headerlink" title="和虚拟机的区别是什么"></a>和虚拟机的区别是什么</h3><ul>
<li>Docker守护进程取代了Hypervisor，它是运行在操作系统之上的后台进程，负责管理Docker容器。</li>
<li>Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。</li>
<li>虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动。（秒级）</li>
<li>由于没有臃肿的从操作系统,Docker可以节省大量的磁盘空间以及其他系统资源。</li>
<li>虚拟机更擅长于彻底隔离整个运行环境，Docker通常用于隔离不同的应用，例如前端，后端以及数据库。本质上来说docker 属于进程之间的隔离，虚拟机可实现系统级别隔离。</li>
<li>安全性： docker 的安全性也更弱。Docker 的租户 root 和宿主机 root 等同，一旦容器内的用户从普通用户权限提升为 root 权限，它就直接具备了宿主机的 root 权限，进而可进行无限制的操作。虚拟机租户 root 权限和宿主机的 root 虚拟机权限是分离的，并且虚拟机利用如 Intel 的 VT-d 和 VT-x 的 ring-1 硬件隔离技术，这种隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击。</li>
</ul>
<h3 id="Docker-核心技术与实现原理"><a href="#Docker-核心技术与实现原理" class="headerlink" title="Docker 核心技术与实现原理"></a>Docker 核心技术与实现原理</h3><h4 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h4><ul>
<li><p>命名空间（namespaces）是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法。在日常使用 Linux 或者 macOS 时，我们并没有运行多个完全分离的服务器的需要，但是如果我们在服务器上启动了多个服务，这些服务其实会相互影响的，每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件，这是很多时候我们都不愿意看到的，我们更希望运行在同一台机器上的不同服务能做到完全隔离，就像运行在多台不同的机器上一样。在这种情况下，一旦服务器上的某一个服务被入侵，那么入侵者就能够访问当前机器上的所有服务和文件，这也是我们不想看到的，而 Docker 其实就通过 Linux 的 Namespaces 对不同的容器实现了隔离。<br>Linux Namespaces机制提供一种资源隔离方案。PID,IPC,Network等系统资源不再是全局性的，而是属于特定的Namespace。每个Namespace里面的资源对其他Namespace都是透明的。要创建新的Namespace，只需要在调用clone时指定相应的flag。Linux Namespaces机制为实现基于容器的虚拟化技术提供了很好的基础，LXC（Linux containers）就是利用这一特性实现了资源的隔离。不同container内的进程属于不同的Namespace，彼此透明，互不干扰。Linux 的命名空间机制提供了以下七种不同的命名空间(flag)，包括 </p>
<p>  <a href="#">CLONE_NEWCGROUP</a></p>
<p>  <a href="#clone-flag2">CLONE_NEWIPC</a></p>
<p>  <a href="#clone-flag4">CLONE_NEWNET</a></p>
<p>  <a href="#clone-flag3">CLONE_NEWNS</a></p>
<p>  <a href="#clone-flag1">CLONE_NEWPID</a></p>
<p>  <a href="#">CLONE_NEWUSER</a></p>
<p>  <a href="#clone-flag5">CLONE_NEWUTS</a></p>
<table>
<thead>
<tr>
<th>flag标记位</th>
<th>功能</th>
<th>隔离的资源</th>
<th>Linux内核版本支持</th>
</tr>
</thead>
<tbody><tr>
<td>CLONE_NEWIPC</td>
<td>在新的 IPC namespace启动新进程</td>
<td>进程间通信，包括信号量、消息队列和共享内存</td>
<td>since 2.6.19</td>
</tr>
<tr>
<td>CLONE_NEWNET</td>
<td>在新的network namespace启动新进程</td>
<td>网络设备、网络栈、端口</td>
<td>since 2.6.24</td>
</tr>
<tr>
<td>CLONE_NEWNS</td>
<td>在新的mount namespace启动新进程</td>
<td>挂载点（文件系统）</td>
<td>since 2.6.19</td>
</tr>
<tr>
<td>CLONE_NEWPID</td>
<td>在新的PID namespace启动新进程</td>
<td>进程编号（新的进程树）</td>
<td>since 2.6.24</td>
</tr>
<tr>
<td>CLONE_NEWUSER</td>
<td>在新的user namespace启动新进程</td>
<td>用户和用户组</td>
<td>在2.6.23引入，在3.5和3.8有更新</td>
</tr>
<tr>
<td>CLONE_NEWUTS</td>
<td>在新的UTS namespace启动新进程</td>
<td>主机名和域</td>
<td>since 2.6.19</td>
</tr>
<tr>
<td>CLONE_NEWCGROUP</td>
<td>在新的cgroup namespace启动新进程</td>
<td>CPU、内存、磁盘读写等</td>
<td>since 4.6</td>
</tr>
</tbody></table>
</li>
</ul>
<p>通过这七个选项我们能在创建新的进程时设置新进程应该在哪些资源上与宿主机器进行隔离。</p>
<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul>
<li><p>进程是 Linux 以及现在操作系统中非常重要的概念，它表示一个正在执行的程序，也是在现代分时系统中的一个任务单元。在每一个 *nix 的操作系统上，我们都能够通过 ps 命令打印出当前操作系统中正在执行的进程，比如在 Ubuntu 上，使用该命令就能得到以下的结果：</p>
<pre><code>  $ ps -ef
  UID        PID  PPID  C STIME TTY          TIME CMD
  root         1     0  0 Apr08 ?        00:00:09 /sbin/init
  root         2     0  0 Apr08 ?        00:00:00 [kthreadd]
  root         3     2  0 Apr08 ?        00:00:05 [ksoftirqd/0]
  root         5     2  0 Apr08 ?        00:00:00 [kworker/0:0H]
  root         7     2  0 Apr08 ?        00:07:10 [rcu_sched]
  root        39     2  0 Apr08 ?        00:00:00 [migration/0]
  root        40     2  0 Apr08 ?        00:01:54 [watchdog/0]
  ...</code></pre>
<p>  当前机器上有很多的进程正在执行，在上述进程中有两个非常特殊，一个是 pid 为 1 的 <a href="#sbin-init">/sbin/init</a> 进程，另一个是 pid 为 2 的 <a href="#kthreadd">kthreadd</a> 进程，这两个进程都是被 Linux 中的上帝进程 <a href="#idle">idle</a> 创建出来的，其中前者负责执行内核的一部分初始化工作和系统配置，也会创建一些类似 <a href="#getty">getty</a> 的注册进程，而后者负责管理和调度其他的内核进程。<br><img src="http://ww1.sinaimg.cn/large/005Seyywly1gidb44br0qj30xc0iwwfc.jpg" alt="undefined"></p>
<p>  如果我们在当前的 Linux 操作系统下运行一个新的 Docker 容器，并通过 exec 进入其内部的 bash 并打印其中的全部进程，我们会得到以下的结果：</p>
<pre><code>  root@iZ255w13cy6Z:~# docker run -it -d ubuntu
  b809a2eb3630e64c581561b08ac46154878ff1c61c6519848b4a29d412215e79
  root@iZ255w13cy6Z:~# docker exec -it b809a2eb3630 /bin/bash
  root@b809a2eb3630:/# ps -ef
  UID        PID  PPID  C STIME TTY          TIME CMD
  root         1     0  0 15:42 pts/0    00:00:00 /bin/bash
  root         9     0  0 15:42 pts/1    00:00:00 /bin/bash
  root        17     9  0 15:43 pts/1    00:00:00 ps -ef</code></pre>
<p>  在新的容器内部执行 ps 命令打印出了非常干净的进程列表，只有包含当前 ps -ef 在内的三个进程，在宿主机器上的几十个进程都已经消失不见了。</p>
<p>  当前的 Docker 容器成功将容器内的进程与宿主机器中的进程隔离，如果我们在宿主机器上打印当前的全部进程时，会得到下面三条与 Docker 相关的结果：</p>
<pre><code>  UID        PID  PPID  C STIME TTY          TIME CMD
  root     29407     1  0 Nov16 ?        00:08:38 /usr/bin/dockerd --raw-logs
  root      1554 29407  0 Nov19 ?        00:03:28 docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval=0 --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --shim docker-containerd-shim --runtime docker-runc
  root      5006  1554  0 08:38 ?        00:00:00 docker-containerd-shim b809a2eb3630e64c5815</code></pre>
<p>  在当前的宿主机器上，可能就存在由上述的不同进程构成的进程树：</p>
<p>  <img src="http://ww1.sinaimg.cn/large/005Seyywly1gidimx92d4j30xc0eg0ts.jpg" alt="undefined"></p>
<p>  这就是在使用 clone(2) 创建新进程时传入 CLONE_NEWPID 实现的，也就是使用 Linux 的命名空间实现进程的隔离，Docker 容器内部的任意进程都对宿主机器的进程一无所知。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">containerRouter.postContainersStart</span><br><span class="line">└── daemon.ContainerStart</span><br><span class="line">└── daemon.createSpec</span><br><span class="line">    └── setNamespaces</span><br><span class="line">        └── setNamespace</span><br></pre></td></tr></table></figure>
<p>Docker 的容器就是使用上述技术实现与宿主机器的进程隔离，当我们每次运行 docker run 或者 docker start 时，都会在下面的方法中创建一个用于设置进程间隔离的 Spec：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (daemon *Daemon) createSpec(c *container.Container) (*specs.Spec, error) &#123;</span><br><span class="line">s :&#x3D; oci.DefaultSpec()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">if err :&#x3D; setNamespaces(daemon, &amp;s, c); err !&#x3D; nil &#123;</span><br><span class="line">    return nil, fmt.Errorf(&quot;linux spec namespaces: %v&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return &amp;s, nil</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>在 setNamespaces 方法中不仅会设置进程相关的命名空间，还会设置与用户、网络、IPC 以及 UTS 相关的命名空间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func setNamespaces(daemon *Daemon, s *specs.Spec, c *container.Container) error &#123;</span><br><span class="line">&#x2F;&#x2F; user</span><br><span class="line">&#x2F;&#x2F; network</span><br><span class="line">&#x2F;&#x2F; ipc</span><br><span class="line">&#x2F;&#x2F; uts</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pid</span><br><span class="line">if c.HostConfig.PidMode.IsContainer() &#123;</span><br><span class="line">    ns :&#x3D; specs.LinuxNamespace&#123;Type: &quot;pid&quot;&#125;</span><br><span class="line">    pc, err :&#x3D; daemon.getPidContainer(c)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    ns.Path &#x3D; fmt.Sprintf(&quot;&#x2F;proc&#x2F;%d&#x2F;ns&#x2F;pid&quot;, pc.State.GetPID())</span><br><span class="line">    setNamespace(s, ns)</span><br><span class="line">&#125; else if c.HostConfig.PidMode.IsHost() &#123;</span><br><span class="line">    oci.RemoveNamespace(s, specs.LinuxNamespaceType(&quot;pid&quot;))</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ns :&#x3D; specs.LinuxNamespace&#123;Type: &quot;pid&quot;&#125;</span><br><span class="line">    setNamespace(s, ns)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return nil</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>所有命名空间相关的设置 Spec 最后都会作为 Create 函数的入参在创建新的容器时进行设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daemon.containerd.Create(context.Background(), container.ID, spec, createOptions)</span><br></pre></td></tr></table></figure>
<p>所有与命名空间的相关的设置都是在上述的两个函数中完成的，Docker 通过命名空间成功完成了与宿主机进程和网络的隔离。</p>
</li>
</ul>
<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul>
<li><p>如果 Docker 的容器通过 Linux 的命名空间完成了与宿主机进程的网络隔离，但是却没有办法通过宿主机的网络与整个互联网相连，就会产生很多限制，所以 Docker 虽然可以通过命名空间创建一个隔离的网络环境，但是 Docker 中的服务仍然需要与外界相连才能发挥作用。<br>每一个使用 docker run 启动的容器其实都具有单独的网络命名空间，Docker 为我们提供了四种不同的网络模式，Host、Container、None 和 Bridge 模式。<br><img src="http://ww1.sinaimg.cn/large/005Seyywly1gidjupewgnj30xc08wdga.jpg" alt="undefined"></p>
<p>  在这一部分，我们将介绍 Docker 默认的网络设置模式：网桥模式。在这种模式下，除了分配隔离的网络命名空间之外，Docker 还会为所有的容器设置 IP 地址。当 Docker 服务器在主机上启动之后会创建新的虚拟网桥 docker0，随后在该主机上启动的全部服务在默认情况下都与该网桥相连。<br><img src="http://ww1.sinaimg.cn/large/005Seyywly1gidjvknip3j30xc0jqq3j.jpg" alt="undefined"></p>
<p>  在默认情况下，每一个容器在创建时都会创建一对虚拟网卡，两个虚拟网卡组成了数据的通道，其中一个会放在创建的容器中，另一个会加入到宿主机名为 docker0 网桥中。我们可以使用如下的命令来查看当前网桥的接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brctl show</span><br><span class="line">bridge name bridge id       STP enabled interfaces</span><br><span class="line">docker0     8000.0242a6654980   no      veth3e84d4f</span><br><span class="line">                                    veth9953b75</span><br></pre></td></tr></table></figure>
<p>docker0 会为每一个容器分配一个新的 IP 地址并将 docker0 的 IP 地址设置为默认的网关。网桥 docker0 通过 iptables 中的配置与宿主机器上的网卡相连，所有符合条件的请求都会通过 iptables 转发到 docker0 并由网桥分发给对应的机器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ iptables -t nat -L</span><br><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">DOCKER     all  --  anywhere             anywhere             ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">RETURN     all  --  anywhere             anywhere</span><br></pre></td></tr></table></figure>
<p>我们在当前的机器上使用 docker run -d -p 6379:6379 redis 命令启动了一个新的 Redis 容器，在这之后我们再查看当前 iptables 的 NAT 配置就会看到在 DOCKER 的链中出现了一条新的规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DNAT       tcp  --  anywhere             anywhere             tcp dpt:6379 to:192.168.0.4:6379</span><br></pre></td></tr></table></figure>
<p>上述规则会将从任意源发送到当前机器 6379 端口的 TCP 包转发到 192.168.0.4:6379 所在的地址上。<br>这个地址其实也是 Docker 为 Redis 服务分配的 IP 地址，如果我们在当前机器上直接 ping 这个 IP 地址就会发现它是可以访问到的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ping 192.168.0.4</span><br><span class="line">PING 192.168.0.4 (192.168.0.4) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.0.4: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.069 ms</span><br><span class="line">64 bytes from 192.168.0.4: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.043 ms</span><br><span class="line">^C</span><br><span class="line">--- 192.168.0.4 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 999ms</span><br><span class="line">rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 0.043&#x2F;0.056&#x2F;0.069&#x2F;0.013 ms</span><br></pre></td></tr></table></figure>
<p>从上述的一系列现象，我们就可以推测出 Docker 是如何将容器的内部的端口暴露出来并对数据包进行转发的了；当有 Docker 的容器需要将服务暴露给宿主机器，就会为容器分配一个 IP 地址，同时向 iptables 中追加一条新的规则。<br><img src="http://ww1.sinaimg.cn/large/005Seyywly1gidk5rmnj2j30xc0m80tf.jpg" alt="undefined"><br>当我们使用 redis-cli 在宿主机器的命令行中访问 127.0.0.1:6379 的地址时，经过 iptables 的 NAT PREROUTING 将 ip 地址定向到了 192.168.0.4，重定向过的数据包就可以通过 iptables 中的 FILTER 配置，最终在 NAT POSTROUTING 阶段将 ip 地址伪装成 127.0.0.1，到这里虽然从外面看起来我们请求的是 127.0.0.1:6379，但是实际上请求的已经是 Docker 容器暴露出的端口了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ redis-cli -h 127.0.0.1 -p 6379 ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>
<p>Docker 通过 Linux 的命名空间实现了网络的隔离，又通过 iptables 进行数据包转发，让 Docker 容器能够优雅地为宿主机器或者其他容器提供服务。</p>
</li>
</ul>
<h4 id="Libnetwork"><a href="#Libnetwork" class="headerlink" title="Libnetwork"></a>Libnetwork</h4><ul>
<li>整个网络部分的功能都是通过 Docker 拆分出来的 libnetwork 实现的，它提供了一个连接不同容器的实现，同时也能够为应用给出一个能够提供一致的编程接口和网络层抽象的容器网络模型。<br>libnetwork 中最重要的概念，容器网络模型由以下的几个主要组件组成，分别是 Sandbox、Endpoint 和 Network：<br><img src="http://ww1.sinaimg.cn/large/005Seyywly1gieeqfra0oj30xc0ci0t4.jpg" alt="undefined"><br>在容器网络模型中，每一个容器内部都包含一个 Sandbox，其中存储着当前容器的网络栈配置，包括容器的接口、路由表和 DNS 设置，Linux 使用网络命名空间实现这个 Sandbox，每一个 Sandbox 中都可能会有一个或多个 Endpoint，在 Linux 上就是一个虚拟的网卡 veth，Sandbox 通过 Endpoint 加入到对应的网络中，这里的网络可能就是我们在上面提到的 Linux 网桥或者 VLAN。</li>
</ul>
<h4 id="挂载点"><a href="#挂载点" class="headerlink" title="挂载点"></a>挂载点</h4><ul>
<li><p>虽然我们已经通过 Linux 的命名空间解决了进程和网络隔离的问题，在 Docker 进程中我们已经没有办法访问宿主机器上的其他进程并且限制了网络的访问，但是 Docker 容器中的进程仍然能够访问或者修改宿主机器上的其他目录，这是我们不希望看到的。</p>
<p>  在新的进程中创建隔离的挂载点命名空间需要在 clone 函数中传入 CLONE_NEWNS，这样子进程就能得到父进程挂载点的拷贝，如果不传入这个参数子进程对文件系统的读写都会同步回父进程以及整个主机的文件系统。</p>
<p>  如果一个容器需要启动，那么它一定需要提供一个根文件系统（rootfs），容器需要使用这个文件系统来创建一个新的进程，所有二进制的执行都必须在这个根文件系统中。<br>  <img src="http://ww1.sinaimg.cn/large/005Seyywly1gieeuyg5zgj30xc0d2q3a.jpg" alt="undefined"></p>
<p>  想要正常启动一个容器就需要在 rootfs 中挂载以上的几个特定的目录，除了上述的几个目录需要挂载之外我们还需要建立一些符号链接保证系统 IO 不会出现问题。<br>  <img src="http://ww1.sinaimg.cn/large/005Seyywly1giefbkqrptj30xc0e674z.jpg" alt="undefined"></p>
<p>  为了保证当前的容器进程没有办法访问宿主机器上其他目录，我们在这里还需要通过 libcotainer 提供的 pivor_root 或者 chroot 函数改变进程能够访问个文件目录的根节点。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pivor_root</span><br><span class="line">put_old &#x3D; mkdir(...);</span><br><span class="line">pivot_root(rootfs, put_old);</span><br><span class="line">chdir(&quot;&#x2F;&quot;);</span><br><span class="line">unmount(put_old, MS_DETACH);</span><br><span class="line">rmdir(put_old);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; chroot</span><br><span class="line">mount(rootfs, &quot;&#x2F;&quot;, NULL, MS_MOVE, NULL);</span><br><span class="line">chroot(&quot;.&quot;);</span><br><span class="line">chdir(&quot;&#x2F;&quot;);</span><br></pre></td></tr></table></figure>
<p>  到这里我们就将容器需要的目录挂载到了容器中，同时也禁止当前的容器进程访问宿主机器上的其他目录，保证了不同文件系统的隔离。</p>
<blockquote>
<p>这一部分的内容是作者在 libcontainer 中的 <a href="https://github.com/opencontainers/runc/blob/master/libcontainer/SPEC.md">SPEC.md</a> 文件中找到的，其中包含了 Docker 使用的文件系统的说明，对于 Docker 是否真的使用 chroot 来确保当前的进程无法访问宿主机器的目录，作者其实也没有确切的答案.</p>
</blockquote>
</li>
</ul>
<h4 id="CGroups"><a href="#CGroups" class="headerlink" title="CGroups"></a>CGroups</h4><ul>
<li><p>我们通过 Linux 的命名空间为新创建的进程隔离了文件系统、网络并与宿主机器之间的进程相互隔离，但是命名空间并不能够为我们提供物理资源上的隔离，比如 CPU 或者内存，如果在同一台机器上运行了多个对彼此以及宿主机器一无所知的『容器』，这些容器却共同占用了宿主机器的物理资源。<br>  <img src="http://ww1.sinaimg.cn/large/005Seyywly1giefnxbwf4j30xc0dwq3g.jpg" alt="undefined"></p>
<p>  如果其中的某一个容器正在执行 CPU 密集型的任务，那么就会影响其他容器中任务的性能与执行效率，导致多个容器相互影响并且抢占资源。如何对多个容器的资源使用进行限制就成了解决进程虚拟资源隔离之后的主要问题，而 Control Groups（简称 CGroups）就是能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I/O 和网络带宽。</p>
<p>  每一个 CGroup 都是一组被相同的标准和参数限制的进程，不同的 CGroup 之间是有层级关系的，也就是说它们之间可以从父类继承一些用于限制资源使用的标准和参数。<br>  <img src="http://ww1.sinaimg.cn/large/005Seyywly1gieforcbl0j30xc0dmmxj.jpg" alt="undefined"></p>
<p>  Linux 的 CGroup 能够为一组进程分配资源，也就是我们在上面提到的 CPU、内存、网络带宽等资源，通过对资源的分配，CGroup 能够提供以下的几种功能：<br>  <img src="http://ww1.sinaimg.cn/large/005Seyywly1giefs4o15ij30xc08wmxp.jpg" alt="undefined"></p>
<blockquote>
<p>在 CGroup 中，所有的任务就是一个系统的一个进程，而 CGroup 就是一组按照某种标准划分的进程，在 CGroup 这种机制中，所有的资源控制都是以 CGroup 作为单位实现的，每一个进程都可以随时加入一个 CGroup 也可以随时退出一个 CGroup。<br>  <a href="https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html">——CGroup 介绍、应用实例及原理描述</a><br>  <a href="https://www.jianshu.com/p/b02bf3b3f265">——Docker之Linux Cgroup实践</a></p>
</blockquote>
<p>  Linux 使用文件系统来实现 CGroup，我们可以直接使用下面的命令查看当前的 CGroup 中有哪些子系统：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lssubsys -m</span><br><span class="line">cpuset &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</span><br><span class="line">cpu &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu</span><br><span class="line">cpuacct &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuacct</span><br><span class="line">memory &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory</span><br><span class="line">devices &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;devices</span><br><span class="line">freezer &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;freezer</span><br><span class="line">blkio &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;blkio</span><br><span class="line">perf_event &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;perf_event</span><br><span class="line">hugetlb &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;hugetlb</span><br></pre></td></tr></table></figure>

<p>  大多数 Linux 的发行版都有着非常相似的子系统，而之所以将上面的 cpuset、cpu 等东西称作子系统，是因为它们能够为对应的控制组分配资源并限制资源的使用。</p>
<p>  如果我们想要创建一个新的 cgroup 只需要在想要分配或者限制资源的子系统下面创建一个新的文件夹，然后这个文件夹下就会自动出现很多的内容，如果你在 Linux 上安装了 Docker，你就会发现所有子系统的目录下都有一个名为 Docker 的文件夹：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls cpu</span><br><span class="line">cgroup.clone_children  </span><br><span class="line">...</span><br><span class="line">cpu.stat  </span><br><span class="line">docker  </span><br><span class="line">notify_on_release </span><br><span class="line">release_agent </span><br><span class="line">tasks</span><br><span class="line"></span><br><span class="line">$ ls cpu&#x2F;docker&#x2F;</span><br><span class="line">9c3057f1291b53fd54a3d12023d2644efe6a7db6ddf330436ae73ac92d401cf1 </span><br><span class="line">cgroup.clone_children  </span><br><span class="line">...</span><br><span class="line">cpu.stat  </span><br><span class="line">notify_on_release </span><br><span class="line">release_agent </span><br><span class="line">tasks</span><br></pre></td></tr></table></figure>

<p>  9c3057xxx 其实就是我们运行的一个 Docker 容器，启动这个容器时，Docker 会为这个容器创建一个与容器标识符相同的 CGroup，在当前的主机上 CGroup 就会有以下的层级关系：<br>  <img src="http://ww1.sinaimg.cn/large/005Seyywly1giegzlwkecj30xc0hsaam.jpg" alt="undefined"></p>
<p>  每一个 CGroup 下面都有一个 tasks 文件，其中存储着属于当前控制组的所有进程的 pid，作为负责 cpu 的子系统，cpu.cfs_quota_us 文件中的内容能够对 CPU 的使用作出限制，如果当前文件的内容为 50000，那么当前控制组中的全部进程的 CPU 占用率不能超过 50%。</p>
<p>  如果系统管理员想要控制 Docker 某个容器的资源使用率就可以在 docker 这个父控制组下面找到对应的子控制组并且改变它们对应文件的内容，当然我们也可以直接在程序运行时就使用参数，让 Docker 进程去改变相应文件中的内容。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -it -d --cpu-quota&#x3D;50000 busybox</span><br><span class="line">53861305258ecdd7f5d2a3240af694aec9adb91cd4c7e210b757f71153cdd274</span><br><span class="line">$ cd 53861305258ecdd7f5d2a3240af694aec9adb91cd4c7e210b757f71153cdd274&#x2F;</span><br><span class="line">$ ls</span><br><span class="line">cgroup.clone_children  cgroup.event_control  cgroup.procs  cpu.cfs_period_us  cpu.cfs_quota_us  cpu.shares  cpu.stat  notify_on_release  tasks</span><br><span class="line">$ cat cpu.cfs_quota_us</span><br><span class="line">50000</span><br></pre></td></tr></table></figure>

<p>  当我们使用 Docker 关闭掉正在运行的容器时，Docker 的子控制组对应的文件夹也会被 Docker 进程移除，Docker 在使用 CGroup 时其实也只是做了一些创建文件夹改变文件内容的文件操作，不过 CGroup 的使用也确实解决了我们限制子容器资源占用的问题，系统管理员能够为多个容器合理的分配资源并且不会出现多个容器互相抢占资源的问题。</p>
</li>
</ul>
<h4 id="UnionFS"><a href="#UnionFS" class="headerlink" title="UnionFS"></a>UnionFS</h4><ul>
<li><p>Linux 的命名空间和控制组分别解决了不同资源隔离的问题，前者解决了进程、网络以及文件系统的隔离，后者实现了 CPU、内存等资源的隔离，但是在 Docker 中还有另一个非常重要的问题需要解决 - 也就是镜像。</p>
<p>  镜像到底是什么，它又是如何组成和组织的是作者使用 Docker 以来的一段时间内一直比较让作者感到困惑的问题，我们可以使用 docker run 非常轻松地从远程下载 Docker 的镜像并在本地运行。</p>
<p>  Docker 镜像其实本质就是一个压缩包，我们可以使用下面的命令将一个 Docker 镜像中的文件导出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker export $(docker create busybox) | tar -C rootfs -xvf -</span><br><span class="line">$ ls</span><br><span class="line">bin  dev  etc  home proc root sys  tmp  usr  var</span><br></pre></td></tr></table></figure>
<p>  你可以看到这个 busybox 镜像中的目录结构与 Linux 操作系统的根目录中的内容并没有太多的区别，可以说 Docker 镜像就是一个文件。</p>
</li>
</ul>
<h4 id="存储驱动"><a href="#存储驱动" class="headerlink" title="存储驱动"></a>存储驱动</h4><ul>
<li><p>Docker 使用了一系列不同的存储驱动管理镜像内的文件系统并运行容器，这些存储驱动与 Docker 卷（volume）有些不同，存储引擎管理着能够在多个容器之间共享的存储。</p>
<p>  想要理解 Docker 使用的存储驱动，我们首先需要理解 Docker 是如何构建并且存储镜像的，也需要明白 Docker 的镜像是如何被每一个容器所使用的；Docker 中的每一个镜像都是由一系列只读的层组成的，Dockerfile 中的每一个命令都会在已有的只读层上创建一个新的层：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:15.04</span><br><span class="line">COPY . &#x2F;app</span><br><span class="line">RUN make &#x2F;app</span><br><span class="line">CMD python &#x2F;app&#x2F;app.py</span><br></pre></td></tr></table></figure>

<p>  容器中的每一层都只对当前容器进行了非常小的修改，上述的 Dockerfile 文件会构建一个拥有四层 layer 的镜像：<br>  <img src="http://ww1.sinaimg.cn/large/005Seyywly1giekx0sd0uj30xc0k0752.jpg" alt="undefined"></p>
<p>  当镜像被 docker run 命令创建时就会在镜像的最上层添加一个可写的层，也就是容器层，所有对于运行时容器的修改其实都是对这个容器读写层的修改。</p>
<p>  容器和镜像的区别就在于，所有的镜像都是只读的，而每一个容器其实等于镜像加上一个可读写的层，也就是同一个镜像可以对应多个容器。<br>  <img src="http://ww1.sinaimg.cn/large/005Seyywly1giekxlw934j30xc0dcdg0.jpg" alt="undefined"></p>
</li>
</ul>
<h4 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h4><ul>
<li><p>UnionFS 其实是一种为 Linux 操作系统设计的用于把多个文件系统『联合』到同一个挂载点的文件系统服务。而 AUFS 即 Advanced UnionFS 其实就是 UnionFS 的升级版，它能够提供更优秀的性能和效率。</p>
<p>  AUFS 作为联合文件系统，它能够将不同文件夹中的层联合（Union）到了同一个文件夹中，这些文件夹在 AUFS 中称作分支，整个『联合』的过程被称为联合挂载（Union Mount）：<br>  <img src="http://ww1.sinaimg.cn/large/005Seyywly1gieladoqu9j30xc0lezlr.jpg" alt="undefined"></p>
<p>  每一个镜像层或者容器层都是 /var/lib/docker/ 目录下的一个子文件夹；在 Docker 中，所有镜像层和容器层的内容都存储在 /var/lib/docker/aufs/diff/ 目录中：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls &#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;diff&#x2F;00adcccc1a55a36a610a6ebb3e07cc35577f2f5a3b671be3dbc0e74db9ca691c       93604f232a831b22aeb372d5b11af8c8779feb96590a6dc36a80140e38e764d8</span><br><span class="line">00adcccc1a55a36a610a6ebb3e07cc35577f2f5a3b671be3dbc0e74db9ca691c-init  93604f232a831b22aeb372d5b11af8c8779feb96590a6dc36a80140e38e764d8-init</span><br><span class="line">019a8283e2ff6fca8d0a07884c78b41662979f848190f0658813bb6a9a464a90       93b06191602b7934fafc984fbacae02911b579769d0debd89cf2a032e7f35cfa</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>  而 /var/lib/docker/aufs/layers/ 中存储着镜像层的元数据，每一个文件都保存着镜像层的元数据，最后的 /var/lib/docker/aufs/mnt/ 包含镜像或者容器层的挂载点，最终会被 Docker 通过联合的方式进行组装。<br>  <img src="http://ww1.sinaimg.cn/large/005Seyywly1gielbaxvx3j30m80go3z3.jpg" alt="undefined"></p>
<p>  上面的这张图片非常好的展示了组装的过程，每一个镜像层都是建立在另一个镜像层之上的，同时所有的镜像层都是只读的，只有每个容器最顶层的容器层才可以被用户直接读写，所有的容器都建立在一些底层服务（Kernel）上，包括命名空间、控制组、rootfs 等等，这种容器的组装方式提供了非常大的灵活性，只读的镜像层通过共享也能够减少磁盘的占用。</p>
</li>
</ul>
<h4 id="其他存储驱动"><a href="#其他存储驱动" class="headerlink" title="其他存储驱动"></a>其他存储驱动</h4><ul>
<li><p>AUFS 只是 Docker 使用的存储驱动的一种，除了 AUFS 之外，Docker 还支持了不同的存储驱动，包括 aufs、devicemapper、overlay2、zfs 和 vfs 等等，在最新的 Docker 中，overlay2 取代了 aufs 成为了推荐的存储驱动，但是在没有 overlay2 驱动的机器上仍然会使用 aufs 作为 Docker 的默认驱动。<br>  <img src="http://ww1.sinaimg.cn/large/005Seyywly1gielca7a42j30xc08wjrv.jpg" alt="undefined"></p>
<p>  不同的存储驱动在存储镜像和容器文件时也有着完全不同的实现，有兴趣的读者可以在 Docker 的官方文档 Select a storage driver 中找到相应的内容。</p>
<p>  想要查看当前系统的 Docker 上使用了哪种存储驱动只需要使用以下的命令就能得到相对应的信息：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker info | grep Storage</span><br><span class="line">Storage Driver: aufs</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Docker 的核心技术其实已经有很多年的历史了，Linux 命名空间、控制组和 UnionFS 三大技术支撑了目前 Docker 的实现，也是 Docker 能够出现的最重要原因。<blockquote>
<p>原文链接：<a href="https://draveness.me/docker">https://draveness.me/docker</a></p>
</blockquote>
</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li><h4 id="clone-flag1"><a href="#clone-flag1" class="headerlink" title="clone-flag1"></a>clone-flag1</h4><p>  当调用clone时，设定了CLONE_NEWPID，就会创建一个新的PID Namespace，clone出来的新进程将成为Namespace里的第一个进程。一个PID Namespace为进程提供了一个独立的PID环境，PID Namespace内的PID将从1开始，在Namespace内调用fork，vfork或clone都将产生一个在该Namespace内独立的PID。新创建的Namespace里的第一个进程在该Namespace内的PID将为1，就像一个独立的系统里的init进程一样。该Namespace内的孤儿进程都将以该进程为父进程，当该进程被结束时，该Namespace内所有的进程都会被结束。PID Namespace是层次性，新创建的Namespace将会是创建该Namespace的进程属于的Namespace的子Namespace。子Namespace中的进程对于父Namespace是可见的，一个进程将拥有不止一个PID，而是在所在的Namespace以及所有直系祖先Namespace中都将有一个PID。系统启动时，内核将创建一个默认的PID Namespace，该Namespace是所有以后创建的Namespace的祖先，因此系统所有的进程在该Namespace都是可见的。</p>
</li>
<li><h4 id="clone-flag2"><a href="#clone-flag2" class="headerlink" title="clone-flag2"></a>clone-flag2</h4><p>  当调用clone时，设定了CLONE_NEWIPC，就会创建一个新的IPC Namespace，clone出来的进程将成为Namespace里的第一个进程。一个IPC Namespace有一组System V IPC objects 标识符构成，这标识符有IPC相关的系统调用创建。在一个IPC Namespace里面创建的IPC object对该Namespace内的所有进程可见，但是对其他Namespace不可见，这样就使得不同Namespace之间的进程不能直接通信，就像是在不同的系统里一样。当一个IPC Namespace被销毁，该Namespace内的所有IPC object会被内核自动销毁。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PID Namespace和IPC Namespace可以组合起来一起使用，只需在调用<span class="built_in">clone</span>时，同时指定CLONE_NEWPID和CLONE_NEWIPC，这样新创建的Namespace既是一个独立的PID空间又是一个独立的IPC空间。不同Namespace的进程彼此不可见，也不能互相通信，这样就实现了进程间的隔离。</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="clone-flag3"><a href="#clone-flag3" class="headerlink" title="clone-flag3"></a>clone-flag3</h4><p>  当调用clone时，设定了CLONE_NEWNS，就会创建一个新的mount Namespace。每个进程都存在于一个mount Namespace里面，mount Namespace为进程提供了一个文件层次视图。如果不设定这个flag，子进程和父进程将共享一个mount Namespace，其后子进程调用mount或umount将会影响到所有该Namespace内的进程。如果子进程在一个独立的mount Namespace里面，就可以调用mount或umount建立一份新的文件层次视图。该flag配合pivot_root系统调用，可以为进程创建一个独立的目录空间。</p>
</li>
<li><h4 id="clone-flag4"><a href="#clone-flag4" class="headerlink" title="clone-flag4"></a>clone-flag4</h4><p>  当调用clone时，设定了CLONE_NEWNET，就会创建一个新的Network Namespace。一个Network Namespace为进程提供了一个完全独立的网络协议栈的视图。包括网络设备接口，IPv4和IPv6协议栈，IP路由表，防火墙规则，sockets等等。一个Network Namespace提供了一份独立的网络环境，就跟一个独立的系统一样。一个物理设备只能存在于一个Network Namespace中，可以从一个Namespace移动另一个Namespace中。虚拟网络设备(virtual network device)提供了一种类似管道的抽象，可以在不同的Namespace之间建立隧道。利用虚拟化网络设备，可以建立到其他Namespace中的物理设备的桥接。当一个Network Namespace被销毁时，物理设备会被自动移回init Network Namespace，即系统最开始的Namespace。</p>
</li>
<li><h4 id="clone-flag5"><a href="#clone-flag5" class="headerlink" title="clone-flag5"></a>clone-flag5</h4><p>  当调用clone时，设定了CLONE_NEWUTS，就会创建一个新的UTS Namespace。一个UTS Namespace就是一组被uname返回的标识符。新的UTS Namespace中的标识符通过复制调用进程所属的Namespace的标识符来初始化。Clone出来的进程可以通过相关系统调用改变这些标识符，比如调用sethostname来改变该Namespace的hostname。这一改变对该Namespace内的所有进程可见。CLONE_NEWUTS和CLONE_NEWNET一起使用，可以虚拟出一个有独立主机名和网络空间的环境，就跟网络上一台独立的主机一样。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">以上所有<span class="built_in">clone</span> flag都可以一起使用，为进程提供了一个独立的运行环境。LXC正是通过在<span class="built_in">clone</span>时设定这些flag，为进程创建一个有独立PID，IPC，FS，Network，UTS空间的container。一个container就是一个虚拟的运行环境，对container里的进程是透明的，它会以为自己是直接在一个系统上运行的。一个container就像传统虚拟化技术里面的一台安装了OS的虚拟机，但是开销更小，部署更为便捷。</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="sbin-init"><a href="#sbin-init" class="headerlink" title="sbin-init"></a>sbin-init</h4><p>  Linux内核加载启动后，用户空间的第一个进程就是初始化进程，这个程序的物理文件约定位于/sbin/init，当然也可以通过传递内核参数来让内核启动指定的程序。这个进程的特点是进程号为1，代表第一个运行的用户空间进程。不同发行版采用了不同的启动程序，主要有以下几种主流选择：</p>
<pre><code>  以 Ubuntu 为代表的 Linux 发行版采用 upstart
  CentOS7.0 版本之前的 System V init
  CentOS7.0 版本的 systemd</code></pre>
</li>
<li><h4 id="kthreadd"><a href="#kthreadd" class="headerlink" title="kthreadd"></a>kthreadd</h4><p>  这种内核线程只有一个，它的作用是管理调度其它的内核线程。这个线程不能关闭。它在内核初始化的时候被创建，会循环运行一个叫做kthreadd的函数，该函数的作用是运行kthread_create_list全局链表中维护的kthread。其他任务或代码想创建内核线程时需要调用kthread_create（或kthread_create_on_node）创建一个kthread，该kthread会被加入到kthread_create_list链表中，同时kthread_create会weak up kthreadd_task（即kthreadd）（增链表）。kthreadd再执行kthread时会调用老的接口——kernel_thread运行一个名叫“kthread”的内核线程去运行创建的kthread，被执行过的kthread会从kthread_create_list链表中删除（减链表），并且kthreadd会不断调用scheduler 让出CPU。kthreadd创建的kthread执行完后，会调到kthread_create()执行，之后再执行最初原任务或代码。</p>
</li>
<li><h4 id="idle"><a href="#idle" class="headerlink" title="idle"></a>idle</h4><p>  简单的说idle是一个进程，其pid号为 0。其前身是系统创建的第一个进程，也是唯一一个没有通过fork()产生的进程。在smp系统中，每个处理器单元有独立的一个运行队列，而每个运行队列上又有一个idle进程，即有多少处理器单元，就有多少idle进程。系统的空闲时间，其实就是指idle进程的”运行时间”。</p>
</li>
<li><h4 id="getty"><a href="#getty" class="headerlink" title="getty"></a>getty</h4><p>  是Unix类操作系统启动时必须的三个步骤之一，用来开启终端，进行终端的初始化，设置终端。</p>
</li>
<li><h4 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h4><p>  在这里不得不简单介绍一下 chroot（change root），在 Linux 系统中，系统默认的目录就都是以 / 也就是根目录开头的，chroot 的使用能够改变当前的系统根目录结构，通过改变当前系统的根目录，我们能够限制用户的权利，在新的根目录下并不能够访问旧系统根目录的结构个文件，也就建立了一个与原系统完全隔离的目录结构。</p>
<blockquote>
<p>与 chroot 的相关内容部分来自<a href="https://developer.ibm.com/zh/technologies/linux/">《理解 chroot》</a>一文，各位读者可以阅读这篇文章获得更详细的信息。</p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
</search>
